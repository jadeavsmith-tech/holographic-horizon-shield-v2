import math
from collections import Counter
import tokenizer  # Reuse Phi-3 tokenizer if available, or simple fallback

def calculate_entropy(prompt: str) -> float:
    # Simple character-level entropy (fast, no extra deps)
    freq = Counter(prompt)
    total = len(prompt)
    entropy = -sum((count / total) * math.log2(count / total) for count in freq.values())
    return entropy

def entropy_scan(prompt: str, threshold: float = 4.5) -> tuple[bool, str]:
    ent = calculate_entropy(prompt)
    if ent > threshold:
        return True, f"High entropy detected ({ent:.2f}) – possible obfuscated attack"
    return False, f"Normal entropy ({ent:.2f})"

# Integrate into shield_core.full_scan() later as an optional early layer
import math
from collections import Counter

def calculate_entropy(prompt: str) -> float:
    """Character-level entropy (higher = more random/obfuscated)"""
    if not prompt:
        return 0.0
    freq = Counter(prompt)
    total = len(prompt)
    return -sum((count / total) * math.log2(count / total) for count in freq.values())

def entropy_scan(prompt: str, threshold: float = 4.8) -> tuple[bool, str]:
    """Early layer: block if entropy too high (tunable)"""
    ent = calculate_entropy(prompt)
    if ent > threshold:
        return True, f"High entropy detected ({ent:.2f} > {threshold}) – possible encoded attack"
    return False, f"Normal entropy ({ent:.2f})"

# Example integration hook (add to shield_core.full_scan later)
# blocked, reason = entropy_scan(prompt)
# if blocked: return {"verdict": "BLOCKED", "layer": "Entropy Layer", "reason": reason}
